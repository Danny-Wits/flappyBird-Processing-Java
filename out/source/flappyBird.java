/* autogenerated by Processing revision 1293 on 2024-11-03 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.*;
import java.util.Arrays;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class flappyBird extends PApplet {



PImage backgroundImage; 
Queue<PipePair> pipeList = new ArrayDeque<>();
String fileLink = "assests/backgroundImage.png";
ArrayList<Bird> birds = new ArrayList<>();
ArrayList<Bird> birdsToADD = new ArrayList<>();
ArrayList<Bird> birdsToSUB = new ArrayList<>();
Pipe pipe;
float gap = 400;
int gapY=3;
float speed = 5;
boolean started=false;
boolean endScreen=false;
int initialBatch=50;
float learnRate=10;
PFont font ;
public void settings(){
   size(displayWidth-300,displayHeight-180);
}
public void setup() {
    addbirds(initialBatch);
    backgroundImage=loadImage(fileLink);
    backgroundImage.resize(width,height);   
}
public void addbirds(int count ){
    for (int i = 0; i < count; ++i) {
        birds.add(new Bird());
     }
}
public void addbirds(int count ,Bird parent ,Bird parent2,Bird parent3){
    if(learnRate>=0.1f){
      learnRate-=0.05f;
    }
    birds.add(parent);
    birds.add(parent2);
    birds.add(parent3);
    for (int i = 0; i < count; ++i) {
        birds.add(parent.child(0.1f));
    }
      for (int i = 0; i < count/2; ++i) {
        birds.add(parent.child());
     }
      for (int i = 0; i < count/2; ++i) {
        birds.add(parent2.child(0.2f));
     }
     for (int i = 0; i < count/3; ++i) {
        birds.add(parent3.child());
     }
}
int count = 0;
int dequeCount = -3 ;
int score = 0;
public void draw() {
    background(backgroundImage); 
    // if(endScreen){
    //     textSize(70);
    //     fill(255);
    //     textAlign(CENTER,CENTER);
    //     text("GAME OVER \n YOUR SCORE :  "+(dequeCount+3)+"\n PRESS 'r' TO CONTINUE",width/2,200 );
    //     return;
    // }  
    // if(!started){
    //     bird.show();
    //     textSize(70);
    //     fill(255);
    //     textAlign(CENTER);
    //     text("PRESS ENTER TO \nSTART/RESTART\nRESUME/PAUSE",width/2, 200);
    //     return;
    // }
    if(count%(60*gapY)==0){
        addPipes();
        if(dequeCount >=0){
            pipeList.poll();
        }
        dequeCount++;
        count=0;
    }
    count++;
    for (PipePair pp : pipeList) {
        pp.move();
        pp.show(); 
    }
    
    for (Bird  bird : birds) {
    bird.physics();
    bird.network();
    bird.show();
   
    if(birds.size()==3){
        birdsToADD.add(birds.get(0).child());
        birdsToADD.add(birds.get(1).child());
        birdsToADD.add(birds.get(2).child());
     }
      if(bird.endGame(pipeList)){
        birdsToSUB.add(bird);
     }
    }
    if(birdsToADD.size()!=0){
    birds.addAll(birdsToADD);
    birdsToADD.clear();
    }
    if(birdsToSUB.size()!=0){
    for (Bird bird : birdsToSUB) {
        birds.remove(bird);
    }
    }
    if(birds.size()==0){
        addbirds(20,birdsToSUB.get(birdsToSUB.size()-1),birdsToSUB.get(birdsToSUB.size()-2),birdsToSUB.get(birdsToSUB.size()-2));
        addbirds(5);
        reset();

        count = 1;
        birdsToADD.clear();
        birdsToSUB.clear();
    }

  
    score = max(score,dequeCount+3);
    textAlign(CENTER,TOP);
    fill(255);
    textSize(50);
    text("Score : "+ score,width/2,30);
    // if (keyPressed==true) {
    //    if(key==' '){
    //     bird.flap();
    //    }
    // }

    
}
public void keyPressed() {
  
        if (keyCode == ENTER) {
            started=!started;
        }
       
       else if(endScreen){
         if (key == 'r'){
            reset();
       }
       }
        
}

public void addPipes(){
   pipeList.add(createPipePair());
}
public PipePair createPipePair(){
    
    float partition = random(0,height-gap);
    Pipe p1 = new Pipe(partition-Pipe.sizeY,true);
    Pipe p2 = new Pipe(partition+gap,false);

    return new PipePair(p1,p2);
}
public void reset(){
    // bird = new Bird();
    dequeCount=-3;
   // speed = 5;
  //  endScreen=false;
  // started=false;
    gapY=3;
    pipeList=new ArrayDeque<PipePair>();
   pipeList.add(createPipePair());
}

public class Bird  {
    public float position = height/4;
    public float positionX=150;
    public float flapStrength=15;
    private float defaultGravity=2;
    public float gravityStrength =defaultGravity;
    public PImage sprite = loadImage("assests/bird.png");
    public float size = 128;
    public Matrix<Float> wm= new Matrix<>(1,5,0.1f);
   
    public int score=0;
    Bird(){
        shuffleWeights();
    }
    Bird(Matrix<Float> wm){
        this.wm=wm;
    }
    public void flap(){
        position-=flapStrength;
        gravityStrength=defaultGravity;
      
    }
    public void network(){
        //input / feed forward 
        Matrix inputMatrix = new Matrix();
        inputMatrix.addRow(position/10);
        boolean shouldFlap =false;
        try {
        var pp = closestPipePair();
         inputMatrix.addRow(pp.getX()-positionX/10);
         inputMatrix.addRow(pp.getT()/10);
         inputMatrix.addRow(pp.getB()/10);
         inputMatrix.addRow(1F);
        
         shouldFlap = activation((Float)Matrix.multiplication(wm,inputMatrix).getValueAt(0,0,0));
        } catch (Exception e) {
           print(e.getMessage()); 
        }
        if(shouldFlap)
        {
            flap();
        //  print(inputMatrix+"\n");
         };
    }
    public Bird child(){
        var child =  new Bird(this.wm);
        child.shuffleWeights();
        return child;
    }
      public Bird child(float limit ){
        var child =  new Bird(this.wm);
        child.shuffleWeights(limit);
        return child;
    }
    public boolean activation(Float x ){
       float f =sigmoid(x/100);
        // print (f+"\n");
        return f>0.98f;
    }
    public float sigmoid(float x ){
         return  (float)(1 / (1 + Math.exp(-(x))));
    }
    public void shuffleWeights(){
        this.wm.setArray((Float[][])wm.map(e ->e + random(-learnRate, learnRate)));
        //  print(wm);
    }
    public void shuffleWeights(float limit){
        this.wm.setArray((Float[][])wm.map(e ->e + random(-limit, limit)));
        //  print(wm);
    }
    public PipePair closestPipePair()  throws Exception{
      for (PipePair pp : pipeList) {
          if(pp.getX()>this.positionX)
           return pp;  
      }
      throw new Exception("No closest pipe");
    }
    public void physics(){
        position+=gravityStrength;
        gravityStrength+=0.2f;
    }
    public void show(){
        image(sprite, positionX, position, size, size);
    }
    public boolean endGame(Queue<PipePair>pipeList){
        return outOfBound()||collisionCheck(pipeList);
    }
    public boolean outOfBound(){
        if(position+size>=height){ position=height-size;  shuffleWeights();}
        if(position<=0 ) { position=0;  shuffleWeights();}
      
        return false;
    }
    public boolean collisionCheck(Queue<PipePair>pipeList){
       for (PipePair p : pipeList) {
            if(collisionCheck(p.top)||collisionCheck(p.bottom)){
                return true;
            }
       }
       return false;
    }
    public boolean collisionCheck(Pipe p ){
        return positionX + size >p.x  && positionX<p.x+Pipe.sizeX&& position+size>p.y && position<p.y+Pipe.sizeY;
    }

}
public class Pipe {
    public float x = width-400;
    public float y = height/2;
    public static final float sizeX =100;
    public static final float sizeY =1000;
    public PImage sprite ;
    Pipe(float y ,boolean fliped){
        this.y=y;
        sprite = loadImage((fliped)?"assests/pipeR.png":"assests/pipe.png");
    }
    public void move(){
        x-=speed;
    }
    public void show(){
        image(sprite,x,y,100,1000);
    } 
    public boolean isOutOfBound(){
        return x<=-sizeX;
    }

    public String toString(){
        return "P";
    }
}
class PipePair{
    public Pipe top;
    public Pipe bottom;
    PipePair(Pipe top , Pipe bottom){
        this.top=top;
        this.bottom=bottom;
    }
    public float getT(){
        return top.y+Pipe.sizeY;
    }
    public float getB(){
        return bottom.y;
    }
    public float getX(){
        return top.x;
    }
    public void move(){
     top.move();
     bottom.move();
    }
    public void show(){
       top.show();
     bottom.show();
    }

}


  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "flappyBird" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
